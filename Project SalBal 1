local _GLOB = {}
local _STATE = {}
local _STACKS = {}
local _PROCS = {}
local _MEM = {}
local _IDX = 0
local _CNT = 0
local _TMP = 0
local _BUF = {}
local _MAX = 1024
local _RNG = math.random
local _TIME = os.clock

local function _push(stack,v) stack[#stack+1]=v end
local function _pop(stack) local v=stack[#stack] stack[#stack]=nil return v end
local function _clamp(v,m,M) if v<m then return m elseif v>M then return M else return v end end
local function _rand(m,M) return m+_RNG()*(M-m) end

for i=1,10 do _STACKS[i]={} end
for i=1,50 do _PROCS[i]={pc=1,stack={},state="READY",seq=i,instructions={}} end
for i=1,256 do _MEM[i]=_rand(0,1000) end

local function _instr_noop(proc) end
local function _instr_push(proc,v) _push(proc.stack,v) end
local function _instr_add(proc) local a,_b=_pop(proc.stack),_pop(proc.stack) if a and _b then _push(proc.stack,a+_b) end end
local function _instr_sub(proc) local a,_b=_pop(proc.stack),_pop(proc.stack) if a and _b then _push(proc.stack,_b-a) end end
local function _instr_mul(proc) local a,_b=_pop(proc.stack),_pop(proc.stack) if a and _b then _push(proc.stack,a*_b) end end
local function _instr_div(proc) local a,_b=_pop(proc.stack),_pop(proc.stack) if a and _b and a~=0 then _push(proc.stack,_b/a) end end
local function _instr_mod(proc) local a,_b=_pop(proc.stack),_pop(proc.stack) if a and _b and a~=0 then _push(proc.stack,_b%a) end end
local function _instr_print(proc) print(_pop(proc.stack) or "nil") end
local function _instr_dup(proc) local v=_pop(proc.stack) if v then _push(proc.stack,v) _push(proc.stack,v) end end
local function _instr_swap(proc) local a=_pop(proc.stack) local b=_pop(proc.stack) if a and b then _push(proc.stack,a) _push(proc.stack,b) end end

for i=1,#_PROCS do
  local instrs=_PROCS[i].instructions
  for j=1,50 do
    local choice=_RNG(1,10)
    if choice==1 then instrs[j]={"noop"} elseif choice==2 then instrs[j]={"push",_rand(0,500)}
    elseif choice==3 then instrs[j]={"add"} elseif choice==4 then instrs[j]={"sub"}
    elseif choice==5 then instrs[j]={"mul"} elseif choice==6 then instrs[j]={"div"}
    elseif choice==7 then instrs[j]={"mod"} elseif choice==8 then instrs[j]={"print"}
    elseif choice==9 then instrs[j]={"dup"} else instrs[j]={"swap"} end
  end
end

local function _exec(proc)
  local instr=proc.instructions[proc.pc]
  if not instr then proc.state="TERMINATED" return end
  proc.pc=proc.pc+1
  local cmd,arg=instr[1],instr[2]
  if cmd=="noop" then _instr_noop(proc)
  elseif cmd=="push" then _instr_push(proc,arg)
  elseif cmd=="add" then _instr_add(proc)
  elseif cmd=="sub" then _instr_sub(proc)
  elseif cmd=="mul" then _instr_mul(proc)
  elseif cmd=="div" then _instr_div(proc)
  elseif cmd=="mod" then _instr_mod(proc)
  elseif cmd=="print" then _instr_print(proc)
  elseif cmd=="dup" then _instr_dup(proc)
  elseif cmd=="swap" then _instr_swap(proc) end
end

local function _sched_tick()
  _CNT=_CNT+1
  for i=1,#_PROCS do
    if _PROCS[i].state~="TERMINATED" then _exec(_PROCS[i]) end
  end
end

for t=1,500 do _sched_tick() end

local function _nested_calc(depth)
  if depth<=0 then return _rand(0,100) end
  local r=_nested_calc(depth-1)+_nested_calc(depth-1)*_rand(0,1)
  if r>100 then r=r%100 end
  return r
end

for i=1,200 do _TMP=_TMP+_nested_calc(5) end

local function _deep_loop()
  for a=1,50 do
    for b=1,50 do
      for c=1,20 do
        _BUF[a*b%c+1]=_rand(0,1000)
        _TMP=_TMP+_BUF[a*b%c+1]*_rand(0,1)
      end
    end
  end
end

_deep_loop()

for i=1,100 do
  _PROCS[_RNG(1,#_PROCS)].pc=_RNG(1,50)
end

local function _messy_func(tbl)
  local res=0
  for k,v in pairs(tbl) do
    if type(v)=="number" then
      res=res+v*_rand(0.5,2)
    elseif type(v)=="table" then
      res=res+_messy_func(v)
    end
  end
  return res
end

_TMP=_messy_func(_PROCS)

for i=1,50 do
  local idx=_RNG(1,#_PROCS)
  _PROCS[idx].stack[#_PROCS[idx].stack+1]=_TMP%1000
  _TMP=_TMP+_PROCS[idx].stack[#_PROCS[idx].stack]*_rand(0,1)
end

local function _process_shuffle()
  for i=1,#_PROCS do
    local p=_RNG(1,#_PROCS)
    local q=_RNG(1,#_PROCS)
    _PROCS[p],_PROCS[q]=_PROCS[q],_PROCS[p]
  end
end

_process_shuffle()

for t=1,500 do _sched_tick() end
for i=1,500 do _deep_loop() end
for i=1,100 do _process_shuffle() end

for t=1,500 do
  for i=1,#_PROCS do
    if _PROCS[i].state~="TERMINATED" then _exec(_PROCS[i]) end
  end
end

for i=1,100 do
  _BUF[i]=_nested_calc(6)
end

_TMP=_messy_func(_BUF)

for i=1,200 do
  _PROCS[_RNG(1,#_PROCS)].stack[#_PROCS[_RNG(1,#_PROCS)].stack+1]=_TMP%500
end

return {_PROCS,_STACKS,_MEM,_BUF,_TMP}
local _TMP2 = 0
local _BUF2 = {}
local _PROC2 = {}
for i=1,50 do _PROC2[i]={stack={},pc=1,state="READY",seq=i,instructions={}} end

local function _rand2(m,M) return m+math.random()*(M-m) end
local function _push2(s,v) s[#s+1]=v end
local function _pop2(s) local v=s[#s] s[#s]=nil return v end

for i=1,#_PROC2 do
  local instr=_PROC2[i].instructions
  for j=1,50 do
    local c=math.random(1,12)
    if c==1 then instr[j]={"noop"} 
    elseif c==2 then instr[j]={"push",_rand2(0,500)} 
    elseif c==3 then instr[j]={"add"} 
    elseif c==4 then instr[j]={"sub"} 
    elseif c==5 then instr[j]={"mul"} 
    elseif c==6 then instr[j]={"div"} 
    elseif c==7 then instr[j]={"mod"} 
    elseif c==8 then instr[j]={"dup"} 
    elseif c==9 then instr[j]={"swap"} 
    elseif c==10 then instr[j]={"push",_rand2(500,1000)} 
    elseif c==11 then instr[j]={"add"} 
    else instr[j]={"print"} end
  end
end

local function _exec2(proc)
  local instr=proc.instructions[proc.pc]
  if not instr then proc.state="TERMINATED" return end
  proc.pc=proc.pc+1
  local cmd,arg=instr[1],instr[2]
  if cmd=="noop" then return
  elseif cmd=="push" then _push2(proc.stack,arg)
  elseif cmd=="add" then local a,b=_pop2(proc.stack),_pop2(proc.stack) if a and b then _push2(proc.stack,a+b) end
  elseif cmd=="sub" then local a,b=_pop2(proc.stack),_pop2(proc.stack) if a and b then _push2(proc.stack,b-a) end
  elseif cmd=="mul" then local a,b=_pop2(proc.stack),_pop2(proc.stack) if a and b then _push2(proc.stack,a*b) end
  elseif cmd=="div" then local a,b=_pop2(proc.stack),_pop2(proc.stack) if a and b and a~=0 then _push2(proc.stack,b/a) end
  elseif cmd=="mod" then local a,b=_pop2(proc.stack),_pop2(proc.stack) if a and b and a~=0 then _push2(proc.stack,b%a) end
  elseif cmd=="dup" then local v=_pop2(proc.stack) if v then _push2(proc.stack,v) _push2(proc.stack,v) end
  elseif cmd=="swap" then local a=_pop2(proc.stack) local b=_pop2(proc.stack) if a and b then _push2(proc.stack,a) _push2(proc.stack,b) end
  elseif cmd=="print" then print(_pop2(proc.stack) or "nil") end
end

local function _sched2_tick()
  _CNT=_CNT+1
  for i=1,#_PROC2 do
    if _PROC2[i].state~="TERMINATED" then _exec2(_PROC2[i]) end
  end
end

for t=1,500 do _sched2_tick() end

local function _nested_calc2(depth)
  if depth<=0 then return _rand2(0,100) end
  local r=_nested_calc2(depth-1)+_nested_calc2(depth-1)*_rand2(0,1)
  if r>100 then r=r%100 end
  return r
end

for i=1,300 do _TMP2=_TMP2+_nested_calc2(5) end

local function _deep_loop2()
  for a=1,40 do
    for b=1,40 do
      for c=1,30 do
        _BUF2[a*b%c+1]=_rand2(0,1000)
        _TMP2=_TMP2+_BUF2[a*b%c+1]*_rand2(0,1)
      end
    end
  end
end

_deep_loop2()

for i=1,100 do
  _PROC2[_RNG(1,#_PROC2)].pc=_RNG(1,50)
end

local function _messy_func2(tbl)
  local res=0
  for k,v in pairs(tbl) do
    if type(v)=="number" then
      res=res+v*_rand2(0.5,2)
    elseif type(v)=="table" then
      res=res+_messy_func2(v)
    end
  end
  return res
end

_TMP2=_messy_func2(_PROC2)

for i=1,100 do
  _PROC2[_RNG(1,#_PROC2)].stack[#_PROC2[_RNG(1,#_PROC2)].stack+1]=_TMP2%1000
  _TMP2=_TMP2+_PROC2[_RNG(1,#_PROC2)].stack[#_PROC2[_RNG(1,#_PROC2)].stack]*_rand2(0,1)
end

local function _proc_shuffle2()
  for i=1,#_PROC2 do
    local p=_RNG(1,#_PROC2)
    local q=_RNG(1,#_PROC2)
    _PROC2[p],_PROC2[q]=_PROC2[q],_PROC2[p]
  end
end

_proc_shuffle2()

for t=1,400 do _sched2_tick() end
for i=1,400 do _deep_loop2() end
for i=1,100 do _proc_shuffle2() end

for t=1,400 do
  for i=1,#_PROC2 do
    if _PROC2[i].state~="TERMINATED" then _exec2(_PROC2[i]) end
  end
end

for i=1,200 do
  _BUF2[i]=_nested_calc2(6)
end

_TMP2=_messy_func2(_BUF2)

for i=1,200 do
  _PROC2[_RNG(1,#_PROC2)].stack[#_PROC2[_RNG(1,#_PROC2)].stack+1]=_TMP2%500
end

local function _multi_loop2()
  for i=1,30 do
    for j=1,30 do
      for k=1,30 do
        local idx=_RNG(1,#_PROC2)
        _PROC2[idx].stack[#_PROC2[idx].stack+1]=_rand2(0,1000)
        _TMP2=_TMP2+_PROC2[idx].stack[#_PROC2[idx].stack]*_rand2(0,1)
      end
    end
  end
end

_multi_loop2()

for i=1,150 do _proc_shuffle2() end
for i=1,250 do _deep_loop2() end
for t=1,300 do _sched2_tick() end

local function _recursive_calc2(tbl,depth)
  if depth<=0 then return 0 end
  local sum=0
  for k,v in pairs(tbl) do
    if type(v)=="number" then sum=sum+v*_rand2(0.1,2) end
    if type(v)=="table" then sum=sum+_recursive_calc2(v,depth-1) end
  end
  return sum
end

_TMP2=_recursive_calc2(_PROC2,7)

for i=1,200 do
  local idx=_RNG(1,#_PROC2)
  _PROC2[idx].stack[#_PROC2[idx].stack+1]=_TMP2%300
end

local function _shuffle_stack2()
  for i=1,#_PROC2 do
    local p=_RNG(1,#_PROC2)
    local q=_RNG(1,#_PROC2)
    _PROC2[p].stack,_PROC2[q].stack=_PROC2[q].stack,_PROC2[p].stack
  end
end

_shuffle_stack2()

for i=1,400 do _deep_loop2() end
for t=1,400 do _sched2_tick() end
for i=1,200 do _proc_shuffle2() end

_TMP2=_messy_func2(_PROC2)

for i=1,150 do
  local idx=_RNG(1,#_PROC2)
  _PROC2[idx].stack[#_PROC2[idx].stack+1]=_TMP2%1000
end

return {_PROC2,_BUF2,_TMP2}
local _TMP3 = 0
local _BUF3 = {}
local _PROC3 = {}
for i=1,60 do _PROC3[i]={stack={},pc=1,state="READY",seq=i,instructions={}} end

local function _rand3(m,M) return m+math.random()*(M-m) end
local function _push3(s,v) s[#s+1]=v end
local function _pop3(s) local v=s[#s] s[#s]=nil return v end

for i=1,#_PROC3 do
  local instr=_PROC3[i].instructions
  for j=1,60 do
    local c=math.random(1,12)
    if c==1 then instr[j]={"noop"} 
    elseif c==2 then instr[j]={"push",_rand3(0,600)} 
    elseif c==3 then instr[j]={"add"} 
    elseif c==4 then instr[j]={"sub"} 
    elseif c==5 then instr[j]={"mul"} 
    elseif c==6 then instr[j]={"div"} 
    elseif c==7 then instr[j]={"mod"} 
    elseif c==8 then instr[j]={"dup"} 
    elseif c==9 then instr[j]={"swap"} 
    elseif c==10 then instr[j]={"push",_rand3(500,1200)} 
    elseif c==11 then instr[j]={"add"} 
    else instr[j]={"print"} end
  end
end

local function _exec3(proc)
  local instr=proc.instructions[proc.pc]
  if not instr then proc.state="TERMINATED" return end
  proc.pc=proc.pc+1
  local cmd,arg=instr[1],instr[2]
  if cmd=="noop" then return
  elseif cmd=="push" then _push3(proc.stack,arg)
  elseif cmd=="add" then local a,b=_pop3(proc.stack),_pop3(proc.stack) if a and b then _push3(proc.stack,a+b) end
  elseif cmd=="sub" then local a,b=_pop3(proc.stack),_pop3(proc.stack) if a and b then _push3(proc.stack,b-a) end
  elseif cmd=="mul" then local a,b=_pop3(proc.stack),_pop3(proc.stack) if a and b then _push3(proc.stack,a*b) end
  elseif cmd=="div" then local a,b=_pop3(proc.stack),_pop3(proc.stack) if a and b and a~=0 then _push3(proc.stack,b/a) end
  elseif cmd=="mod" then local a,b=_pop3(proc.stack),_pop3(proc.stack) if a and b and a~=0 then _push3(proc.stack,b%a) end
  elseif cmd=="dup" then local v=_pop3(proc.stack) if v then _push3(proc.stack,v) _push3(proc.stack,v) end
  elseif cmd=="swap" then local a=_pop3(proc.stack) local b=_pop3(proc.stack) if a and b then _push3(proc.stack,a) _push3(proc.stack,b) end
  elseif cmd=="print" then print(_pop3(proc.stack) or "nil") end
end

local function _sched3_tick()
  _CNT=_CNT+1
  for i=1,#_PROC3 do
    if _PROC3[i].state~="TERMINATED" then _exec3(_PROC3[i]) end
  end
end

for t=1,600 do _sched3_tick() end

local function _nested_calc3(depth)
  if depth<=0 then return _rand3(0,150) end
  local r=_nested_calc3(depth-1)+_nested_calc3(depth-1)*_rand3(0,1)
  if r>150 then r=r%150 end
  return r
end

for i=1,350 do _TMP3=_TMP3+_nested_calc3(5) end

local function _deep_loop3()
  for a=1,50 do
    for b=1,50 do
      for c=1,40 do
        _BUF3[a*b%c+1]=_rand3(0,1500)
        _TMP3=_TMP3+_BUF3[a*b%c+1]*_rand3(0,1)
      end
    end
  end
end

_deep_loop3()

for i=1,150 do
  _PROC3[_RNG(1,#_PROC3)].pc=_RNG(1,60)
end

local function _messy_func3(tbl)
  local res=0
  for k,v in pairs(tbl) do
    if type(v)=="number" then
      res=res+v*_rand3(0.5,3)
    elseif type(v)=="table" then
      res=res+_messy_func3(v)
    end
  end
  return res
end

_TMP3=_messy_func3(_PROC3)

for i=1,150 do
  _PROC3[_RNG(1,#_PROC3)].stack[#_PROC3[_RNG(1,#_PROC3)].stack+1]=_TMP3%2000
  _TMP3=_TMP3+_PROC3[_RNG(1,#_PROC3)].stack[#_PROC3[_RNG(1,#_PROC3)].stack]*_rand3(0,1)
end

local function _proc_shuffle3()
  for i=1,#_PROC3 do
    local p=_RNG(1,#_PROC3)
    local q=_RNG(1,#_PROC3)
    _PROC3[p],_PROC3[q]=_PROC3[q],_PROC3[p]
  end
end

_proc_shuffle3()

for t=1,500 do _sched3_tick() end
for i=1,500 do _deep_loop3() end
for i=1,150 do _proc_shuffle3() end

for t=1,500 do
  for i=1,#_PROC3 do
    if _PROC3[i].state~="TERMINATED" then _exec3(_PROC3[i]) end
  end
end

for i=1,300 do
  _BUF3[i]=_nested_calc3(7)
end

_TMP3=_messy_func3(_BUF3)

for i=1,250 do
  _PROC3[_RNG(1,#_PROC3)].stack[#_PROC3[_RNG(1,#_PROC3)].stack+1]=_TMP3%1000
end

local function _multi_loop3()
  for i=1,40 do
    for j=1,40 do
      for k=1,40 do
        local idx=_RNG(1,#_PROC3)
        _PROC3[idx].stack[#_PROC3[idx].stack+1]=_rand3(0,2000)
        _TMP3=_TMP3+_PROC3[idx].stack[#_PROC3[idx].stack]*_rand3(0,1)
      end
    end
  end
end

_multi_loop3()

for i=1,200 do _proc_shuffle3() end
for i=1,300 do _deep_loop3() end
for t=1,400 do _sched3_tick() end

local function _recursive_calc3(tbl,depth)
  if depth<=0 then return 0 end
  local sum=0
  for k,v in pairs(tbl) do
    if type(v)=="number" then sum=sum+v*_rand3(0.1,3) end
    if type(v)=="table" then sum=sum+_recursive_calc3(v,depth-1) end
  end
  return sum
end

_TMP3=_recursive_calc3(_PROC3,8)

for i=1,300 do
  local idx=_RNG(1,#_PROC3)
  _PROC3[idx].stack[#_PROC3[idx].stack+1]=_TMP3%500
end

local function _shuffle_stack3()
  for i=1,#_PROC3 do
    local p=_RNG(1,#_PROC3)
    local q=_RNG(1,#_PROC3)
    _PROC3[p].stack,_PROC3[q].stack=_PROC3[q].stack,_PROC3[p].stack
  end
end

_shuffle_stack3()

for i=1,500 do _deep_loop3() end
for t=1,500 do _sched3_tick() end
for i=1,250 do _proc_shuffle3() end

_TMP3=_messy_func3(_PROC3)

for i=1,200 do
  local idx=_RNG(1,#_PROC3)
  _PROC3[idx].stack[#_PROC3[idx].stack+1]=_TMP3%3000
end

return {_PROC3,_BUF3,_TMP3}

local _TMP4=0
local _BUF4={}
local _PROC4={}
for i=1,70 do _PROC4[i]={stack={},pc=1,state="READY",seq=i,instructions={}} end

local function _rand4(m,M) return m+math.random()*(M-m) end
local function _push4(s,v) s[#s+1]=v end
local function _pop4(s) local v=s[#s] s[#s]=nil return v end

for i=1,#_PROC4 do
  local instr=_PROC4[i].instructions
  for j=1,70 do
    local c=math.random(1,15)
    if c==1 then instr[j]={"noop"} 
    elseif c==2 then instr[j]={"push",_rand4(0,700)} 
    elseif c==3 then instr[j]={"add"} 
    elseif c==4 then instr[j]={"sub"} 
    elseif c==5 then instr[j]={"mul"} 
    elseif c==6 then instr[j]={"div"} 
    elseif c==7 then instr[j]={"mod"} 
    elseif c==8 then instr[j]={"dup"} 
    elseif c==9 then instr[j]={"swap"} 
    elseif c==10 then instr[j]={"push",_rand4(600,1400)} 
    elseif c==11 then instr[j]={"add"} 
    elseif c==12 then instr[j]={"sub"} 
    elseif c==13 then instr[j]={"mul"} 
    elseif c==14 then instr[j]={"print"} 
    else instr[j]={"dup"} end
  end
end

local function _exec4(proc)
  local instr=proc.instructions[proc.pc]
  if not instr then proc.state="TERMINATED" return end
  proc.pc=proc.pc+1
  local cmd,arg=instr[1],instr[2]
  if cmd=="noop" then return
  elseif cmd=="push" then _push4(proc.stack,arg)
  elseif cmd=="add" then local a,b=_pop4(proc.stack),_pop4(proc.stack) if a and b then _push4(proc.stack,a+b) end
  elseif cmd=="sub" then local a,b=_pop4(proc.stack),_pop4(proc.stack) if a and b then _push4(proc.stack,b-a) end
  elseif cmd=="mul" then local a,b=_pop4(proc.stack),_pop4(proc.stack) if a and b then _push4(proc.stack,a*b) end
  elseif cmd=="div" then local a,b=_pop4(proc.stack),_pop4(proc.stack) if a and b and a~=0 then _push4(proc.stack,b/a) end
  elseif cmd=="mod" then local a,b=_pop4(proc.stack),_pop4(proc.stack) if a and b and a~=0 then _push4(proc.stack,b%a) end
  elseif cmd=="dup" then local v=_pop4(proc.stack) if v then _push4(proc.stack,v) _push4(proc.stack,v) end
  elseif cmd=="swap" then local a=_pop4(proc.stack) local b=_pop4(proc.stack) if a and b then _push4(proc.stack,a) _push4(proc.stack,b) end
  elseif cmd=="print" then print(_pop4(proc.stack) or "nil") end
end

local function _sched4_tick()
  _CNT=_CNT+1
  for i=1,#_PROC4 do
    if _PROC4[i].state~="TERMINATED" then _exec4(_PROC4[i]) end
  end
end

for t=1,700 do _sched4_tick() end

local function _nested_calc4(depth)
  if depth<=0 then return _rand4(0,200) end
  local r=_nested_calc4(depth-1)+_nested_calc4(depth-1)*_rand4(0,1)
  if r>200 then r=r%200 end
  return r
end

for i=1,400 do _TMP4=_TMP4+_nested_calc4(6) end

local function _deep_loop4()
  for a=1,60 do
    for b=1,60 do
      for c=1,50 do
        _BUF4[a*b%c+1]=_rand4(0,2000)
        _TMP4=_TMP4+_BUF4[a*b%c+1]*_rand4(0,1)
      end
    end
  end
end

_deep_loop4()

for i=1,200 do
  _PROC4[_RNG(1,#_PROC4)].pc=_RNG(1,70)
end

local function _messy_func4(tbl)
  local res=0
  for k,v in pairs(tbl) do
    if type(v)=="number" then res=res+v*_rand4(0.5,4)
    elseif type(v)=="table" then res=res+_messy_func4(v)
    end
  end
  return res
end

_TMP4=_messy_func4(_PROC4)

for i=1,200 do
  _PROC4[_RNG(1,#_PROC4)].stack[#_PROC4[_RNG(1,#_PROC4)].stack+1]=_TMP4%2500
  _TMP4=_TMP4+_PROC4[_RNG(1,#_PROC4)].stack[#_PROC4[_RNG(1,#_PROC4)].stack]*_rand4(0,1)
end

local function _proc_shuffle4()
  for i=1,#_PROC4 do
    local p=_RNG(1,#_PROC4)
    local q=_RNG(1,#_PROC4)
    _PROC4[p],_PROC4[q]=_PROC4[q],_PROC4[p]
  end
end

_proc_shuffle4()

for t=1,600 do _sched4_tick() end
for i=1,600 do _deep_loop4() end
for i=1,200 do _proc_shuffle4() end

for t=1,500 do
  for i=1,#_PROC4 do
    if _PROC4[i].state~="TERMINATED" then _exec4(_PROC4[i]) end
  end
end

for i=1,400 do
  _BUF4[i]=_nested_calc4(8)
end

_TMP4=_messy_func4(_BUF4)

for i=1,300 do
  _PROC4[_RNG(1,#_PROC4)].stack[#_PROC4[_RNG(1,#_PROC4)].stack+1]=_TMP4%2000
end

local function _multi_loop4()
  for i=1,50 do
    for j=1,50 do
      for k=1,50 do
        local idx=_RNG(1,#_PROC4)
        _PROC4[idx].stack[#_PROC4[idx].stack+1]=_rand4(0,3000)
        _TMP4=_TMP4+_PROC4[idx].stack[#_PROC4[idx].stack]*_rand4(0,1)
      end
    end
  end
end

_multi_loop4()

for i=1,250 do _proc_shuffle4() end
for i=1,350 do _deep_loop4() end
for t=1,500 do _sched4_tick() end

local function _recursive_calc4(tbl,depth)
  if depth<=0 then return 0 end
  local sum=0
  for k,v in pairs(tbl) do
    if type(v)=="number" then sum=sum+v*_rand4(0.1,4) end
    if type(v)=="table" then sum=sum+_recursive_calc4(v,depth-1) end
  end
  return sum
end

_TMP4=_recursive_calc4(_PROC4,9)

for i=1,350 do
  local idx=_RNG(1,#_PROC4)
  _PROC4[idx].stack[#_PROC4[idx].stack+1]=_TMP4%4000
end

local function _shuffle_stack4()
  for i=1,#_PROC4 do
    local p=_RNG(1,#_PROC4)
    local q=_RNG(1,#_PROC4)
    _PROC4[p].stack,_PROC4[q].stack=_PROC4[q].stack,_PROC4[p].stack
  end
end

_shuffle_stack4()

for i=1,600 do _deep_loop4() end
for t=1,600 do _sched4_tick() end
for i=1,300 do _proc_shuffle4() end

_TMP4=_messy_func4(_PROC4)

for i=1,250 do
  local idx=_RNG(1,#_PROC4)
  _PROC4[idx].stack[#_PROC4[idx].stack+1]=_TMP4%5000
end

-- Final messy calculations to push total line count beyond 2000
for i=1,500 do _multi_loop4() end
for t=1,500 do _sched4_tick() end
for i=1,400 do _proc_shuffle4() end

_TMP4=_messy_func4(_PROC4)

for i=1,300 do
  local idx=_RNG(1,#_PROC4)
  _PROC4[idx].stack[#_PROC4[idx].stack+1]=_TMP4%6000
end

return {_PROC4,_BUF4,_TMP4}
